1. leader选举

init初始化函数，用于设置raft节点，并检查各项参数的正确性。
```c++
int NodeImpl::init(const NodeOptions& options)
// 初始化投票定时器、投票定时器、降级定时器和快照定时器
|- CHECK_EQ(0, _election_timer.init(this, options.election_timeout_ms)); 
|- CHECK_EQ(0, _vote_timer.init(this, options.election_timeout_ms + options.max_clock_drift_ms));
|- CHECK_EQ(0, _stepdown_timer.init(this, options.election_timeout_ms));
|- CHECK_EQ(0, _snapshot_timer.init(this, options.snapshot_interval_s * 1000));

// 用于维护状态机
|- _fsm_caller = new FSMCaller();
// 初始化leader租约
|- _leader_lease.init(options.election_timeout_ms);
// 初始化witness租约，* 2的意义是让witness发起投票晚于follower，所以不能当选leader
|- if (options.witness) {
        _follower_lease.init(options.election_timeout_ms * 2, options.max_clock_drift_ms);
    } else {
        _follower_lease.init(options.election_timeout_ms, options.max_clock_drift_ms);
    }
// 用于节点投票
|- _ballot_box = new BallotBox();
// 初始化快照存储
|- init_snapshot_storage();
// 初始化元数据存储，并检查任期
|- init_meta_storage();
// 将当前状态设置为跟随者
|- _state = STATE_FOLLOWER;
// 启动快照定时器
|- _snapshot_timer.start();
// 将本节点添加到节点管理器中
|- global_node_manager->add(this);
// 若满足条件，触发定时器，使当前服务器成为领导者
|- elect_self(&lck);
```
在初始化状态下，满足条件的节点会立即发起elect_self，在一般场景中，若follower发现leader超时，会首先发起prevote，
它会遍历所有peer，发送preVote Rpc请求。

```c++
void NodeImpl::pre_vote()
// 回调函数
|- OnPreVoteRPCDone* done = new OnPreVoteRPCDone(*iter, _current_term, this);
|- for:
    OnPreVoteRPCDone* done = new OnPreVoteRPCDone(*iter, _current_term, this);
    RaftService_Stub stub(&channel);
    stub.pre_vote(&done->cntl, &done->request, &done->response, done);
```

每个peer收到上述rpc:
```c++
void RaftServiceImpl::pre_vote()
|- node->handle_pre_vote_request(request, response);
|-- NodeImpl::handle_pre_vote_request()
    bool granted = false;
    // request里面的term比自己小，granted为false
    if (request->term() < _current_term) { 
        ...
        break;
    }
    // term一致，比较日志索引
    LogId last_log_id = _log_manager->last_log_id(true);
    granted = (LogId(request->last_log_index(), request->last_log_term())
                    >= last_log_id);
```

发起prevote的node在收到RPC响应后回调NodeImpl::handle_pre_vote_response。
```c++
void NodeImpl::handle_pre_vote_response()
    // response中的term大于自身的，通过 step_down 回退到 follower 状态
    if (response.term() > _current_term) {
        ...
        step_down(response.term(), false, status);
        return;
    }
    // 收到投票， _pre_vote_ctx记录投票情况，当获取到一半+1票，发起elect_self
    if (response.granted()) {
        _pre_vote_ctx.grant(peer_id);
        if (_pre_vote_ctx.granted()) {
            elect_self(&lck);
        }
    }
}
```
pre_vote的意义在于：

与论文不同，在 braft 代码中，选举之前会有一次预选举（prevote）的过程，来源于 raft 作者的博士论文。

在基础的 raft 算法中，当一个 follower 节点与其他节点发生网络分区时，由于心跳超时，会主动发起一次选举，每次选举时会把 term 加一。由于网络分区的存在，每次 RequestVote RPC 都会超时，结果是，一直不断地发起新的选举，term 会不断增大。

在网络分区恢复，重新加入集群后，其 term 值会被其他节点知晓，导致其他节点更新自己的 term，并变为 follower。然后触发重新选举，但被隔离的节点日志不是最新，并不会竞选成功，整个集群的状态被该节点扰乱。

Prevote 算法是 raft 作者在其博士论文中提出的，在节点发起一次选举时，会先发起一次 prevote 请求，判断是否能够赢得选举，赢得选举的条件与正常选举相同。如果可以，则增加 term 值，并发起正常的选举。
参考：https://zhuanlan.zhihu.com/p/169840204

```c++
void NodeImpl::elect_self(std::unique_lock<raft_mutex_t>* lck) {
    LOG(INFO) << "node " << _group_id << ":" << _server_id
              << " term " << _current_term << " start vote and grant vote self";
    ...
    // 1. 如果当前是follower状态，则停止_election_timer
    if (_state == STATE_FOLLOWER) {
        BRAFT_VLOG << "node " << _group_id << ":" << _server_id
                   << " term " << _current_term << " stop election_timer";
        _election_timer.stop();
    }
    // 2. 将leader设置为空
    ...
    reset_leader_id(empty_id, status);

    // 3. 把状态设置为candidate，_current_term加一，然后给自己投票
    _state = STATE_CANDIDATE;
    _current_term++;
    _voted_id = _server_id;

    // 4. 启动_vote_timer，该定时器负责选举阶段的超时
    ...
    _vote_timer.start();
    _vote_ctx.init(_conf.conf, _conf.stable() ? NULL : &_conf.old_conf);

    // 5. 获取最新的log
    ...
    const LogId last_log_id = _log_manager->last_log_id(true);
    ...
   
    // 6. 与prevote类似，获取所有peer，并向其他节点发起RequestVoteRPC。不过它调用的是RaftService的request_vote函数，回调是OnRequestVoteRPCDone
    for (std::set<PeerId>::const_iterator
        iter = peers.begin(); iter != peers.end(); ++iter) {
        ...
        OnRequestVoteRPCDone* done = new OnRequestVoteRPCDone(*iter, _current_term, this);
        ...
        RaftService_Stub stub(&channel);
        stub.request_vote(&done->cntl, &done->request, &done->response, done);
    }

    // 7. 给自己投票，并检查投票结果：
    _meta_storage->set_term_and_votedfor(_current_term, _server_id);
    _vote_ctx.grant(_server_id);
    if (_vote_ctx.granted()) {
        become_leader();
    }
}
```
注意NodeImpl::init中对几种计时器进行了初始化，但是在启动时xxx_timer.start();会在限定范围内重新生成一个随机的超时时间，其目的是使每个节点的超时时间不一致，避免有两个节点同时发起投票导致选票五五开。

收到RequestVoteRPC的节点处理请求:

```c++
int NodeImpl::handle_request_vote_request(const RequestVoteRequest* request,
                                          RequestVoteResponse* response) {
    ...

    do {
        // 1. 如果request中的term大于自己的term，则回退到follower状态并重启election_timeout
        if (request->term() >= _current_term) {
            ...
            if (request->term() > _current_term) {
                ...
                step_down(request->term(), false, status);
            }
        } else {
            ...
        }

        // 2. 获取最新log_id:
        ...
        LogId last_log_id = _log_manager->last_log_id(true);
        ...
        
        // 3. 如果request中的log比自身的新，而且当前节点还没投票的话，就回退到Follower并给candidate投票。

        bool log_is_ok = (LogId(request->last_log_index(), request->last_log_term())
                          >= last_log_id);
        if (log_is_ok && _voted_id.is_empty()) {
            ...
            step_down(request->term(), false, status);
            _voted_id = candidate_id;
            _meta_storage->set_votedfor(candidate_id);
        }
    } while (0);
    ...
}
```
发起rpc的节点收到response后处理请求:
```c++
void NodeImpl::handle_request_vote_response(const PeerId& peer_id, const int64_t term,
                                            const RequestVoteResponse& response) {
    BAIDU_SCOPED_LOCK(_mutex);

    // 1. 首先要确认当前状态是不是candidate（因为可能选举已经成功，节点已经成为leader了）
    if (_state != STATE_CANDIDATE) {
        ...
    }
    // 2. 然后检查term是不是等于当前term（有可能收到来自上一次rpc的response）
    if (term != _current_term) {
        ...
    }
    // 3. 如果收到的term大于自身的term，则回退到follower状态。
    if (response.term() > _current_term) {
        ...
        step_down(response.term(), false, status);
        return;
    }

    // 4. 最后检查response的granted，设置 _vote_ctx的granted，然后检查当前是否赢得选举（策略和prevote一样），如果赢了，就调用become_leader
    if (response.granted()) {
        _vote_ctx.grant(peer_id);
        if (_vote_ctx.granted()) {
            become_leader();
        }
    }
}
```
如果vote_timer被触发的时候节点还处于candidate状态（也就是没选出leader）的话，就会调用NodeImpl::handle_vote_timeout, 如果设置了raft_step_down_when_vote_timedout，就回退到follower开始新的prevote，否则就直接开始新的选举。

